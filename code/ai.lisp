(let (
  (at (lambda (f l i) (if (eq i 0) (car l) (call f f (cdr l) (sub i 1)))))
  (contains (lambda (f l x)
    (if (atom l)
      0
      (if (eq x (car l))
        1
        (call f f (cdr l) x))))))
(let (
  (mapat (lambda (map x y) (call at at (call at at map y) x))))
(let (
  (step (lambda (gst world)
     (let ((map (car world))
           (st (car (cdr world)))
           (p 0) (x 0) (y 0)
           (nx 0) (ny 0) (nz 0)
           (cur 0) (nxt 0) (tile 0) (enq 0) (queued 0)
           (ansz 0))
     (let ((enq (lambda (cx dx cy dy z)
          (let ((tx (add cx dx)) (ty (add cy dy)))
            (if (call contains contains queued (add tx (mul ty 1000)))
              (seq)
              (seq
                (set queued (cons (add tx (mul ty 1000)) queued))
                (set nxt (cons (cons z (cons tx ty)) nxt))))))))
       (set p (car (cdr st)))
       (set x (car p))
       (set y (cdr p))
       (call enq x 0 y -1 0)
       (call enq x 1 y 0 1)
       (call enq x 0 y 1 2)
       (call enq x -1 y 0 3)
       (while (eq 0 (atom nxt))
          (set cur nxt)
          (set nxt 0)
          (while (eq 0 (atom cur))
            (set nz (car (car cur)))
            (set nx (car (cdr (car cur))))
            (set ny (cdr (cdr (car cur))))
            (set cur (cdr cur))
            (set tile (call mapat map nx ny))
            (if (eq 0 tile)
              (seq)
              (if (add (eq 2 tile) (eq 3 tile))
                (seq (set ansz nz)
                     (set cur 0)
                     (set nxt 0))
                (seq (call enq nx 0 ny -1 nz)
                     (call enq nx 1 ny 0 nz)
                     (call enq nx 0 ny 1 nz)
                     (call enq nx -1 ny 0 nz))))))
       (cons (add 1 gst) ansz))))))
  (cons 0 step)
)))
